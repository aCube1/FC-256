Virtual FC-256 CPU

Virtual 16-bit machine heavily inspired by SNES(Super Nintendo Entertainment System).
Endianess: Little-Endian

-----------------------------------------------------------------------------------------

Instruction specification:
- Instruction: <mnemonic> [[operand['H|'L]], [operand['H|'L]]]
- format: 0CCSSSAA-AAAIIIII
 - IIIII: 5-bits opcode identifier;
 - AAAAA: 5-bits address mode;
 - SSS: 3-bit access mode;
 - CC: 2-bits register count.
  - 0b00: No Registers;
  - 0b01: 1 Register;
  - 0b10: 2 Registers;
  - 0b11: INVALID.

Access Modes:
* Instructions can access the High or Low byte from operands using 'H or 'L postfixes.
 Code | First | Second
 0x00 | NOREG | NOREG
 0x01 | Word  | Word
 0x02 | Low   | Low
 0x03 | Low   | High
 0x04 | High  | High
 0x05 | High  | Low
 0x06 | UNDEF | UNDEF
 0x07 | UNDEF | UNDEF

* Example: MOV rX'L, 0x4269'H
 This will store the High byte from 0x4269 (0x42) on the Low byte of register rX.

General registers:
* Can be accessed as operands. If the operand has registers, then an extra byte
after instruction specify the selection.
Nibble | Name | Usage
0b0000 |  r0  | Data and Address
0b0001 |  r1  | Data and Address
0b0010 |  r2  | Data and Address
0b0011 |  r3  | Data and Address
0b0100 |  rA  | Data and Address
0b0101 |  rB  | Data and Address
0b0110 |  rC  | Data and Address
0b0111 |  rD  | Data and Address
0b1000 |  rE  | Data and Address
0b1001 |  rF  | Data and Address
0b1010 |  rW  | Data and Address
0b1011 |  rX  | Data and Address
0b1100 |  rY  | Data and Address
0b1101 |  rZ  | Data and Address
0b1110 |  PC  | Program counter
0b1111 |  SP  | Stack pointer

* All registers are 16-bits wide.
* If the operand contains more than 1 register, the lower nibble specify the
first register, and the high nibble specify the second register.
* Example: MOV r2, rA
 The register count is 2, r2=0x02 and rA=0x04, so the extra byte is 0x42.

Internal registers:
* Cannot be accessed as operands
- BB: Program bank (256 banks);
- DB: Data bank (256 banks);
- P: Program status (---IOCNZ).
 - I: Disable Interrupt;
 - O: Overflow/Underflow;
 - C: Carry;
 - N: Negative;
 - Z: Zero.

* All registers are 8-bits wide.

Address modes:
 Code | Name      | Operand
 0x00 | Implied   | No Operand
 0x01 | Relative  | Const
 0x02 | Immediate | Const
 0x03 | Immediate | rX, Const
 0x04 | Register  | rX
 0x05 | Register  | rX, rY
 0x06 | Absolute  | (Addr)
 0x07 | Absolute  | rX, (Addr)
 0x08 | Absolute  | (Addr), rX
 0x09 | Indexed   | (Addr + Const)
 0x0a | Indexed   | rX, (Addr + Const)
 0x0b | Indexed   | (Addr + Const), rY
 0x0c | Indirect  | (rX)
 0x0d | Indirect  | rX, (rY)
 0x0e | Indirect  | (rX), rY
 0x0f | Long Abs  | (LAddr)
 0x10 | Long Abs  | rX, (LAddr)
 0x11 | Long Abs  | (LAddr), rX
 0x12 | Long Ind  | (LAddr + Const)
 0x13 | Long Ind  | rX, (LAddr + Const)
 0x14 | Long Ind  | (LAddr + Const), rX
 0x15 | NoMode    | RESERVED
 0x16 | NoMode    | RESERVED
 0x17 | NoMode    | RESERVED
 0x18 | NoMode    | RESERVED
 0x19 | NoMode    | RESERVED
 0x1a | NoMode    | RESERVED
 0x1b | NoMode    | RESERVED
 0x1c | NoMode    | RESERVED
 0x1d | NoMode    | RESERVED
 0x1e | NoMode    | RESERVED
 0x1f | NoMode    | RESERVED

Banking:
* There are 2 registers for bank switching: BB and DB.

* The BB register keeps track of the current bank for the executed instruction.
If the current instruction is at address 0x0f2001, this register will hold the
value of 0x0f, and the PC (Program Counter) will hold the value 0x2001.

* The DB register holds the data bank address. When using the absolute or indexed
addressing modes with a long address, an extra byte will be added before the
actual address. So if instruction uses 0x246942 address, the CPU will read the
extra byte(0x24) and store it on the register.
