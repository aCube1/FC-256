Virtual FC-256 CPU

Virtual 16-bit machine heavily inspired by SNES(Super Nintendo Entertainment System).
Endianess: Little-Endian

-----------------------------------------------------------------------------------------

Instruction specification:
- Instruction: <mnemonic> [operands]
- format: 0000AAAA-CCIIIIII
 - IIIIII: 6-bits opcode identifier;
 - CC: 2-bits register count.
  - 0b00: No Registers;
  - 0b01: 1 Register;
  - 0b10: 2 Registers;
  - 0b11: INVALID.
 - AAAA: 4-bits address mode;

General registers:
* Can be accessed as operands. If the operand has registers, then an extra byte
after instruction specify the selection.
Nibble | Name | Usage
0b0000 |  r0  | Data and Address
0b0001 |  r1  | Data and Address
0b0010 |  r2  | Data and Address
0b0011 |  r3  | Data and Address
0b0100 |  rA  | Data and Address
0b0101 |  rB  | Data and Address
0b0110 |  rC  | Data and Address
0b0111 |  rD  | Data and Address
0b1000 |  rE  | Data and Address
0b1001 |  rF  | Data and Address
0b1010 |  rW  | Data and Address
0b1011 |  rX  | Data and Address
0b1100 |  rY  | Data and Address
0b1101 |  rZ  | Data and Address
0b1110 |  PC  | Program counter
0b1111 |  SP  | Stack pointer

* All registers are 16-bits wide.
* If the operand contains more than 1 register, the lower nibble specify the
first register, and the high nibble specify the second register.
* Example: MOV r2, rA
 The register count is 2, r2=0x02 and rA=0x04, so the extra byte is 0x42.

Internal registers:
* Cannot be accessed as operands
- BB: Program bank (256 banks);
- DB: Data bank (256 banks);
- P: Program status (---IOCNZ).
 - I: Disable Interrupt;
 - O: Overflow/Underflow;
 - C: Carry;
 - N: Negative;
 - Z: Zero.

* All registers are 8-bits wide.

Address modes:
 Code | Name      | Operand
 0x00 | NoMode    | RESERVED
 0x01 | Implied   | No Operand
 0x02 | Relative  | Branch
 0x03 | Immediate | Const
 0x04 | Immediate | rX, Const
 0x05 | Register  | rX
 0x06 | Register  | rX, rY
 0x07 | Absolute  | (Addr)
 0x08 | Absolute  | rX, (Addr)
 0x09 | Absolute  | (Addr), rX
 0x0a | Indexed   | (Addr + Const)
 0x0b | Indexed   | rX, (Addr + Const)
 0x0c | Indexed   | (Addr + Const), rX
 0x0d | Indirect  | (rX)
 0x0e | Indirect  | rX, (rY)
 0x0f | Indirect  | (rX), rY

Banking:
* There are 2 registers for bank switching: BB and DB.

* The BB register keeps track of the current bank for the executed instruction.
If the current instruction is at address 0x0f2001, this register will hold the
value of 0x0f, and the PC (Program Counter) will hold the value 0x2001.

* The DB register holds the data bank address. When using the absolute or indexed
addressing modes with a long address, an extra byte will be added before the
actual address. So if instruction uses 0x246942 address, the CPU will read the
extra byte(0x24) and store it on the register.
